<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:docbook50-profile.xsl"
 type="text/xml"
 title="Profiling step"?>
<!DOCTYPE appendix
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->
<appendix xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="app.security.pcidss">
<!-- This chapter is very much WIP and not ready for publication. -->
 <title>SUSE Linux Enterprise Server PCI DSS Guide</title>
 <info>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:bugtracker>
          </dm:bugtracker>
      </dm:docmanager>
    </info>
    <!-- This chapter is very much WIP and not ready for publication. -->

<sect1>
<title>Introduction</title>
 <para>
  Any company that handles card payments from customers will need to protect
  their data and keep it as safe and secure as possible. This is on a mutual
  basis to protect customers and the business itself. For this, it is important
  to evaluate all aspects of the business environment that are somehow involved
  in processing cardholder data. The PCI Data Security Standards helps to cover
  all areas that are somehow part of the process and to implement security
  relevant actions to keep the data and the environment it relies on save.
</para>

<para>
  An essential part is the combination of actions. It is not only necessary to
  configure a secure service, it is also important that the configuration
  is not changed afterwards. If something is changed, it is important to keep
  track on who changed what at what point in time. This SUSE security guide
  should give you a basic understanding of how &sle; can be
  configured to comply with the PCI Data Security Standard. Again, it is most important to understand that protecting the systems does not end by the configuration. It is the whole environment and people involved that needs to be taken into account.
</para>
</sect1>

<sect1>
  <title>What is PCI DSS?</title>
  <para>
The Payment Card Industry Data Security Standard (PCI DSS) is a set of
requirements to guide a merchant to protect credit cardholder data. The
standard covers 6 main categories with currently 12 requirement topics how to
implement, protect, maintain and monitor systems that are involved with credit
cardholder data processing.
</para>

<para>
PCI DSS was created and is maintained by the PCI Security Standards Council
(SSC) that was founded by all five major credit card companies: Visa, MasterCard,
American Express, Discover, and JCB. In December 2004 PCI DSS 1.0 was released
to address the growing threat of online credit card fraud. The current version
3.2 was released in April 2016.
</para>
<itemizedlist>
<listitem>
<para>
  Build and Maintain a Secure Network and Systems
</para>
<itemizedlist>
<listitem>
<para>
  Install and maintain a firewall configuration to protect cardholder data
</para>
</listitem>
<listitem>
<para>
  Do not use vendor-supplied defaults for system passwords and other security parameters
</para>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
  Protect Cardholder Data
</para>
<itemizedlist>
<listitem>
<para>
  Protect stored cardholder data
</para>
</listitem>
<listitem>
<para>
  Encrypt transmission of cardholder data across open, public networks
</para>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
  Maintain a Vulnerability Management Program
</para>
<itemizedlist>
<listitem>
<para>
  Protect all systems against malware and regularly update anti-virus software or programs
</para>
</listitem>
<listitem>
<para>
  Develop and maintain secure systems and applications
</para>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
  Implement Strong Access Control Measures
</para>
<itemizedlist>
<listitem>
<para>
  Restrict access to cardholder data by business need to know
</para>
</listitem>
<listitem>
<para>
  Identify and authenticate access to system components
</para>
</listitem>
<listitem>
<para>
  Restrict physical access to cardholder data
</para>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
  Regularly Monitor and Test Networks
</para>
<itemizedlist>
<listitem>
<para>
  Track and monitor all access to network resources and cardholder data
</para>
</listitem>
<listitem>
<para>
  Regularly test security systems and processes
</para>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
  Maintain an Information Security Policy
</para>
<itemizedlist>
<listitem>
<para>
  Maintain a policy that addresses information security for all personnel
</para>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>

<para>
  Most of the requirements described are organizational guidelines that help to
  ensure the security of all areas involved with cardholder data. The technical
  aspects are usually specified kind of fuzzy. This leads to a situation where
  it is up to the auditor to decide which security setting is valid for a
  requirement and which is not. So the described recommendations in this guide
  are just a starting point to fulfill the PCI DSS and are objects of
  discussion. 
</para>
</sect1>

<sect1>
<title>Areas relevant to the Operating System</title>
<para>
  As PCI DSS  encompasses all aspects related to credit cardholder data, not
  all requirements concern directly the operating system (OS). For example, the running application processing the data and the database design are not directly within the scope of the OS security. Also, formal processes that need to be implemented are not directly related to the OS level.
</para>
<para>
  Relevant are the areas where the OS can be configured to enforce the policies
  described inside the requirements. This applies to system security settings
  and access control as well as system maintenance to protect against known security vulnerabilities.
</para>
</sect1>

<sect1>
<title>Requirements in Detail</title>
<sect2>
<title>Build and Maintain a Secure Network and Systems</title>
<variablelist>
  <varlistentry>
<term>Install and maintain a firewall configuration to protect cardholder
data</term>
<listitem>
<para>
  The listed terms in this section are mostly design, documentation and formal
  process requirements. All changes to the firewalls and routers are need to be
  approved, documented and verified and all stakeholders need to be
  involved. The network design includes a DMZ environment, access to the
  Internet, a protected network for database servers, traffic filtering rules
  between network segments etc. In addition to a dedicated firewall and router,
  SUSE Linux Enterprise come with a host firewall based on iptables. The system
  can be easily configured to allow only connections on certain inbound
  ports. With the YaST firewall module it is also possible to define more
  complex rules, for instance that connections are only possible from certain
  network addresses. With this the local system firewall should be part of the
  overall firewall design to tighten network security to a maximum.
</para>
<para>
The first technical point in requirement 1 is the identification of insecure
services and protocols. After that it comes down to limiting the traffic to and
from the system to tighten up the boundaries so that unneeded and unwanted
traffic is directly avoided.
</para>
</listitem>
  </varlistentry>

<varlistentry>
<term>Identify insecure services, protocols, and ports allowed; and verify
that security features are documented for each service</term>
<listitem>
<para>
This task is embedded into the requirement to identify, document and justify all services and protocols running on a system. A special interest are services and protocols that could lead to a security risk. If a certain insecure service or protocol is used it needs to be evaluated and understood how big the security impact could be. A service or protocol that is not for business operation should be disabled or removed.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Examine firewall and router configurations to verify that inbound and
outbound traffic is limited to that which is necessary for the cardholder data
environment</term>
<listitem>
<para>
Inbound traffic filtering rules can be directly defined via the YaST firewall
module. Systems with multiple interfaces can be configured in such a way that
for example the ssh daemon is only reachable on the administration interface
and not on the general network card. Furthermore is possible to define the
source addresses that a service allows traffic from.</para>

<para>
Usually all outbound system traffic is generally allowed with the <filename>SuSEfirewall2</filename>
script. Therefore outbound rules need to be defined manually inside the
<filename>SuSEfirewall2-custom</filename> script. The activation of the custom script has to be done
inside the general SuSEfirewall configuration file
<filename>/etc/sysconfig/SuSEfirewall2</filename> by un-commenting the FW_CUSTOMRULES line.
</para>

<para>
To add an outbound rule simply add the needed iptables command inside the fw_custom_after_chain_creation() function. This function hook gets executed during the firewall setup and allows any customized iptables rule.
The following example would only allow outbound DNS requests over interface
eth0 to server 10.0.0.4. Please check the “deny all” OUTPUT rule described in
requirement 1.2.1.c.</para>

<screen>iptables -A OUTPUT -d 10.0.0.4/32 -o eth0 -p udp -m udp --dport 53 -j
ACCEPT</screen>
</listitem>
</varlistentry>

<varlistentry>
<term>Examine firewall and router configurations to verify that all other
inbound and outbound traffic is specifically denied, for example by using an
explicit “deny all” or an implicit deny after allow statement</term>
<listitem>
<para>
The "deny all" rules of other inbound and outbound traffic can easily be achieved with iptables. The INPUT and FORWARD table policies are directly set by the SuSEfirewall2 script so that all unwanted traffic gets droped. (Forwarding is usually completely disabled by a kernel parameter and shouldn't be enabled for endpoint servers.)
</para>

<para>
As mentioned before the OUTPUT policy has to be defined manually inside the
<filename>SuSEfirewall2-custom</filename> script because in general all
outgoing traffic is allowed. The following two rules need to be added to the
fw_custom_after_chain_creation() function so that only outbound traffic that is
related to an established inbound connection is allowed.</para>

<screen>iptables -A OUTPUT -m conntrack --ctstate ESTABLISHED -j ACCEPT
	iptables -P OUTPUT DROP</screen>

<para>
In addition inbound traffic can also be configured for certain services via the
tcp wrapper configuration file <filename>/etc/hosts.deny</filename>.</para>

<para>
Most of the following tasks are about examine and verifying that the defined
inbound and outbound rules are really limiting the traffic between and within
all network segments, like the DMZ and the Internet, to a needed minimum for
full system operation.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Implement anti-spoofing measures to detect and block forged source IP
addresses from entering the network</term>
<listitem>
<para>
There a two ways to implement anti-spoofing measurements in &sle;. The first
one is the use of iptables rules that only allow input from certain addresses
on specified interfaces. The used address space for communications can be
clearly defined by system setup. Any use of addresses that violate this
definitions can be logged and trigger an alarm. The second way is provided via
the Linux kernel reverse path filtering. The basic concept of this feature is
that if a packet reply wouldn’t go out through the same interface the initial
packet got in, it is treated as a bogus packet and is dropped. This feature is
enabled by default in &sle; and can be check with the following command. This
should give back a 1 when it is enabled.</para>
<screen>cat /proc/sys/net/ipv4/conf/all/rp_filter</screen>
</listitem>
</varlistentry>

<varlistentry>
<term>Permit only established connections into the network</term>
<listitem>
<para>
SuSEfirewall2 directly enables connection tracking via iptables. Connections to
an interface that has been marked as external are dropped by default. Only
connections that associated with an established connection are allowed.</para>

<para>
It is possible to define certain services that are allowed to connect to the
external interface. However, this has to be in compliance with the general
security policy.</para>

<para>
Please keep in mind that the first line of defense to block malicious
connections from the internet should be a dedicated firewall system that
handles all traffic and acts as a gate keeper. Unwanted connections should
never reach the DMZ network. However, simple firewall rules on the SUSE Linux
Enterprise systems can help to avoid misconfiguration issues and act as another
line in the defense mechanism.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Do not disclose private IP addresses and routing information to
unauthorized parties</term>
<listitem>
<para>
A &sle; system can also act as a router to forward traffic from one interface
to another network on a second interface. It is possible to use Network Address
Translation (NAT) on the external interface so that no internal IP address is
actually exposed to outside. This is done to mitigate the information an
external attacker can gather by simply analyzing the network traffic. NAT can
also be used on virtulization hosts or container based environments that
connect to the outside via a specific interface.
</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2>
<title>Do not use vendor-supplied defaults for system passwords and other security parameters</title>
<para>
During system installation of &sle; general system passwords
are already set by the administrator. The setup uses also a password checker
(cracklib) that identifies weak entries against a common dictionary. So for
most services the standard configuration comes already with customer defined
security options.
</para>
<para>
This is also stated inside the SUSE Linux Enterprise Server Security and
Hardening Guide, that should be a general resource to tighten security
further. This helps to meet the requirements in this section.
</para>

<variablelist>
<varlistentry>
<term>Always change vendor-supplied defaults and remove or disable unnecessary
default accounts before installing a system on the network</term>
<listitem>
<para>
The configuration of any system service has to be evaluated to meet the needed
security standards. This goes from limiting the used protocols to only allow
currently secure versions and to disable legacy implementations, to the
definition of access controls and authentication. SUSE Linux Enterprise
predefined settings are already security aware, but settings can be tightened
ever further. For example, this is the case with the SNMP daemon where by
default incoming requests are only allowed to localhost. The default community
string is named 'public' and should be changed before accepting general inbound
connections.</para>

<para>
A second example are the default settings of the ssh daemon that are listed and
commented out inside the sshd configuration file '/etc/ssh/sshd_config'. On
default the insecure protocol 1 is already disabled. The same goes for
permitting empty passwords (PermitEmptyPasswords no). To tighten ssh security
it would best practice to deny direct root access by setting “PermitRootLogin”
to no.
</para>

<para>
Default settings can also be customized during automated system installation
via an AutoYaST profile. This makes it easy to roll out new instances of &sles;
and directly enable an evaluated configuration. The whole setup procedure can
even be completely automated with the SUSE Manager[2]. &sle; does not install
additional default accounts apart of the root administration user. There are
system accounts defined in /etc/passwd, but they are not activated and
therefore not directly reachable. This can be validated by checking the lines
inside the /etc/shadow file. The second column represents the defined
password. An asterisk (*) at this place means that no password was ever defined
and the account is therefore locked. An exclamation (!) stands for a locked
account and can stand all by itself or in front of a password hash.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Develop configuration standards for all system components. Assure that
these standards address all known security vulnerabilities and are consistent
with industry-accepted system hardening standards</term>
<listitem>
<para>
As mentioned inside the PCI DSS document, possible sources for
industry-accepted hardening standards are:
</para>

<itemizedlist>
<listitem>
<para>
Center for Internet Security (CIS)
</para>
</listitem>
<listitem>
<para>
International Organization for Standardization (ISO)
</para>
</listitem>
<listitem>
<para>
SysAdmin Audit Network Security (SANS) Institute
</para>
</listitem>
<listitem>
<para>
National Institute of Standards Technology (NIST)
</para>
</listitem>
</itemizedlist>

<para>
In general, as the PCI DSS requirements are quite fuzzy, there is no direct
mapping of hardening standards to specific requirements. However, any hardening
resource, including the SLES Security and Hardening Guide[1], help to fulfill
this specifications.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Implement only one primary function per server to prevent functions that
require different security levels from co-existing on the same server</term>
<listitem>
<para>
(For example, web servers, database servers, and DNS should be implemented on
separate servers.)
</para>

<para>
With &sles; it is easily possible to separate services by
using virtualization. SLES12 SP1 comes with the virtualization methods KVM,
Xen, Linux Containers and Docker to isolate services. This makes it easy to
fulfill the requirement and isolate services from each other. It is also
possible to run SLES on proprietary virtualization servers like VMware ESX or
Microsoft Hyper-V to achieve service separation.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Enable only necessary services, protocols, daemons, etc., as required for
the function of the system</term>
<listitem>
<para>
This requirement is aligned with the firewall requirement 1.1.6.b to allow only
services that are really needed and are using secure protocols and
settings. All involved parties need to be aware of the impact of using insecure
communication that could be comprised. The risk of using insecure protocols
and/or services should be clearly understood and documented.
</para>

<para>
Since SLES12 enabling and disabling system services is done via
systemd. Changes can be entered by using the systemctl tool.
</para>
<screen>systemctl status [SERVICE]
	systemctl enable [SERVICE]
	systemctl disable [SERVICE]</screen>

<para>
To list all available services that are installed on the system and see their status use the following command.
	systemctl list-unit-files –type=service
      </para>
</listitem>
</varlistentry>

<varlistentry>
<term>Inspect configuration settings to verify that security features are
documented and implemented for all insecure services, daemons, or
protocols</term>
<listitem>
<para>
One way to add an additional layer of security to insecure services is the
usage of VPN tunnels (i.e. IPsec). With this, the network traffic of such
services can be isolated and all data, internally and externally, is protected
against eavesdropping. It must be clear that the communication is still
insecure at the endpoints of the VPN tunnel and that this is just a workaround.
</para>
<para>
Additional security within SUSE Linux Enterprise Server can also be provided
with the usage of SELinux or AppArmor. At this stage the setup of these methods
is beyond the scope of this document. A good starting point to get familiar
with the SELinux framework is main chapter V of the SUSE Linux Enterprise
Server 12 SP1 Security Guide.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Select a sample of system components and inspect the configurations to
verify that all unnecessary functionality (for example, scripts, drivers,
features, subsystems, file systems, etc.) is removed</term>
<listitem>
<para>
One main system component is the Linux kernel that consist of a core image that
is extended by numerous kernel modules depending on the used hardware and
system design. Network card drivers are automatically loaded depending on the
availability inside the system and filesystem modules are used to extend the
Linux kernel's functionality. The list of loaded kernel modules is usually
quite long and includes modules that are only used occasionally. The kernel
module framework makes it easy to blacklist certain modules and to limit the
functionality.
</para>

<para>A simple way to block modules from being loaded is the configuration via
the /etc/modprobe.d directory. For instance, if we would like to prevent the
kernel module 'floppy' from being loaded, as systems these days have usually no
floppy drive anymore, we create the following configuration file.

File: /etc/modprobe.d/00-disable-modules.conf
	install floppy /bin/true
</para>

<para>
Please be aware that the floppy module is usually loaded during the execution of the initial ram disk. Therefore it is necessary to propagate such a configuration change to the initrd file. This has to be done via the ''mkinitrd'' script.
	mkinitrd
</para>
<para>
It is not that easy to do the same with application functionality. Usually the
functionality is compiled into the binaries itself or be part of a library,
which makes it impossible to being removed explicitly. Furthermore it has to be
clear that removed files that where part of an RPM package are reinstalled when
a package update is published.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Encrypt all non-console administrative access using strong
cryptography. Use technologies such as SSH, VPN, or TLS for web-based
management and other non-console administrative access
</term>
<listitem>
<para>
It is quite straight forward to fulfill this requirement. Any administrative
network access needs to be encrypted. The first tool of choice here is SSH with
appropriate configuration settings that fit into the security
concept. Administrative access can also be granted via a website. In this case
the complete connection chain between the browser and the server system needs
to be encrypted. This is done via TLS and x509 certificates.
</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>



</sect1>
</appendix>
