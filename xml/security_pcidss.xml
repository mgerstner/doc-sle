<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:docbook50-profile.xsl"
 type="text/xml"
 title="Profiling step"?>
<!DOCTYPE appendix
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->
<appendix xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="app.security.pcidss">
<!-- This chapter is very much WIP and not ready for publication. -->
 <title>SUSE Linux Enterprise Server PCI DSS Guide</title>
 <info>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:bugtracker>
          </dm:bugtracker>
      </dm:docmanager>
    </info>
    <!-- This chapter is very much WIP and not ready for publication. -->

<sect1>
<title>Introduction</title>
 <para>
  Any company that handles card payments from customers will need to protect
  their data and keep it as safe and secure as possible. This is on a mutual
  basis to protect customers and the business itself. For this, it is important
  to evaluate all aspects of the business environment that are somehow involved
  in processing cardholder data. The PCI Data Security Standards helps to cover
  all areas that are somehow part of the process and to implement security
  relevant actions to keep the data and the environment it relies on save.
</para>

<para>
  An essential part is the combination of actions. It is not only necessary to
  configure a secure service, it is also important that the configuration
  is not changed afterwards. If something is changed, it is important to keep
  track on who changed what at what point in time. This SUSE security guide
  should give you a basic understanding of how &sle; can be
  configured to comply with the PCI Data Security Standard. Again, it is most important to understand that protecting the systems does not end by the configuration. It is the whole environment and people involved that needs to be taken into account.
</para>
</sect1>

<sect1>
  <title>What is PCI DSS?</title>
  <para>
The Payment Card Industry Data Security Standard (PCI DSS) is a set of
requirements to guide a merchant to protect credit cardholder data. The
standard covers 6 main categories with currently 12 requirement topics how to
implement, protect, maintain and monitor systems that are involved with credit
cardholder data processing.
</para>

<para>
PCI DSS was created and is maintained by the PCI Security Standards Council
(SSC) that was founded by all five major credit card companies: Visa, MasterCard,
American Express, Discover, and JCB. In December 2004 PCI DSS 1.0 was released
to address the growing threat of online credit card fraud. The current version
3.2 was released in April 2016.
</para>
<itemizedlist>
<listitem>
<para>
  Build and Maintain a Secure Network and Systems
</para>
<itemizedlist>
<listitem>
<para>
  Install and maintain a firewall configuration to protect cardholder data
</para>
</listitem>
<listitem>
<para>
  Do not use vendor-supplied defaults for system passwords and other security parameters
</para>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
  Protect Cardholder Data
</para>
<itemizedlist>
<listitem>
<para>
  Protect stored cardholder data
</para>
</listitem>
<listitem>
<para>
  Encrypt transmission of cardholder data across open, public networks
</para>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
  Maintain a Vulnerability Management Program
</para>
<itemizedlist>
<listitem>
<para>
  Protect all systems against malware and regularly update anti-virus software or programs
</para>
</listitem>
<listitem>
<para>
  Develop and maintain secure systems and applications
</para>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
  Implement Strong Access Control Measures
</para>
<itemizedlist>
<listitem>
<para>
  Restrict access to cardholder data by business need to know
</para>
</listitem>
<listitem>
<para>
  Identify and authenticate access to system components
</para>
</listitem>
<listitem>
<para>
  Restrict physical access to cardholder data
</para>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
  Regularly Monitor and Test Networks
</para>
<itemizedlist>
<listitem>
<para>
  Track and monitor all access to network resources and cardholder data
</para>
</listitem>
<listitem>
<para>
  Regularly test security systems and processes
</para>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
  Maintain an Information Security Policy
</para>
<itemizedlist>
<listitem>
<para>
  Maintain a policy that addresses information security for all personnel
</para>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>

<para>
  Most of the requirements described are organizational guidelines that help to
  ensure the security of all areas involved with cardholder data. The technical
  aspects are usually specified kind of fuzzy. This leads to a situation where
  it is up to the auditor to decide which security setting is valid for a
  requirement and which is not. So the described recommendations in this guide
  are just a starting point to fulfill the PCI DSS and are objects of
  discussion. 
</para>
</sect1>

<sect1>
<title>Areas relevant to the Operating System</title>
<para>
  As PCI DSS  encompasses all aspects related to credit cardholder data, not
  all requirements concern directly the operating system (OS). For example, the running application processing the data and the database design are not directly within the scope of the OS security. Also, formal processes that need to be implemented are not directly related to the OS level.
</para>
<para>
  Relevant are the areas where the OS can be configured to enforce the policies
  described inside the requirements. This applies to system security settings
  and access control as well as system maintenance to protect against known security vulnerabilities.
</para>
</sect1>

<sect1>
<title>Requirements in Detail</title>
<sect2>
<title>Build and Maintain a Secure Network and Systems</title>
<variablelist>
  <varlistentry>
<term>Install and maintain a firewall configuration to protect cardholder
data</term>
<listitem>
<para>
  The listed terms in this section are mostly design, documentation and formal
  process requirements. All changes to the firewalls and routers are need to be
  approved, documented and verified and all stakeholders need to be
  involved. The network design includes a DMZ environment, access to the
  Internet, a protected network for database servers, traffic filtering rules
  between network segments etc. In addition to a dedicated firewall and router,
  SUSE Linux Enterprise come with a host firewall based on iptables. The system
  can be easily configured to allow only connections on certain inbound
  ports. With the YaST firewall module it is also possible to define more
  complex rules, for instance that connections are only possible from certain
  network addresses. With this the local system firewall should be part of the
  overall firewall design to tighten network security to a maximum.
</para>
<para>
The first technical point in requirement 1 is the identification of insecure
services and protocols. After that it comes down to limiting the traffic to and
from the system to tighten up the boundaries so that unneeded and unwanted
traffic is directly avoided.
</para>
</listitem>
  </varlistentry>

<varlistentry>
<term>Identify insecure services, protocols, and ports allowed; and verify
that security features are documented for each service</term>
<listitem>
<para>
This task is embedded into the requirement to identify, document and justify all services and protocols running on a system. A special interest are services and protocols that could lead to a security risk. If a certain insecure service or protocol is used it needs to be evaluated and understood how big the security impact could be. A service or protocol that is not for business operation should be disabled or removed.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Examine firewall and router configurations to verify that inbound and
outbound traffic is limited to that which is necessary for the cardholder data
environment</term>
<listitem>
<para>
Inbound traffic filtering rules can be directly defined via the YaST firewall
module. Systems with multiple interfaces can be configured in such a way that
for example the ssh daemon is only reachable on the administration interface
and not on the general network card. Furthermore is possible to define the
source addresses that a service allows traffic from.</para>

<para>
Usually all outbound system traffic is generally allowed with the <filename>SuSEfirewall2</filename>
script. Therefore outbound rules need to be defined manually inside the
<filename>SuSEfirewall2-custom</filename> script. The activation of the custom script has to be done
inside the general SuSEfirewall configuration file
<filename>/etc/sysconfig/SuSEfirewall2</filename> by un-commenting the FW_CUSTOMRULES line.
</para>

<para>
To add an outbound rule simply add the needed iptables command inside the fw_custom_after_chain_creation() function. This function hook gets executed during the firewall setup and allows any customized iptables rule.
The following example would only allow outbound DNS requests over interface
eth0 to server 10.0.0.4. Please check the “deny all” OUTPUT rule described in
requirement 1.2.1.c.</para>

<screen>iptables -A OUTPUT -d 10.0.0.4/32 -o eth0 -p udp -m udp --dport 53 -j
ACCEPT</screen>
</listitem>
</varlistentry>

<varlistentry>
<term>Examine firewall and router configurations to verify that all other
inbound and outbound traffic is specifically denied, for example by using an
explicit “deny all” or an implicit deny after allow statement</term>
<listitem>
<para>
The "deny all" rules of other inbound and outbound traffic can easily be achieved with iptables. The INPUT and FORWARD table policies are directly set by the SuSEfirewall2 script so that all unwanted traffic gets droped. (Forwarding is usually completely disabled by a kernel parameter and shouldn't be enabled for endpoint servers.)
</para>

<para>
As mentioned before the OUTPUT policy has to be defined manually inside the
<filename>SuSEfirewall2-custom</filename> script because in general all
outgoing traffic is allowed. The following two rules need to be added to the
fw_custom_after_chain_creation() function so that only outbound traffic that is
related to an established inbound connection is allowed.</para>

<screen>iptables -A OUTPUT -m conntrack --ctstate ESTABLISHED -j ACCEPT
	iptables -P OUTPUT DROP</screen>

<para>
In addition inbound traffic can also be configured for certain services via the
tcp wrapper configuration file <filename>/etc/hosts.deny</filename>.</para>

<para>
Most of the following tasks are about examine and verifying that the defined
inbound and outbound rules are really limiting the traffic between and within
all network segments, like the DMZ and the Internet, to a needed minimum for
full system operation.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Implement anti-spoofing measures to detect and block forged source IP
addresses from entering the network</term>
<listitem>
<para>
There a two ways to implement anti-spoofing measurements in &sle;. The first
one is the use of iptables rules that only allow input from certain addresses
on specified interfaces. The used address space for communications can be
clearly defined by system setup. Any use of addresses that violate this
definitions can be logged and trigger an alarm. The second way is provided via
the Linux kernel reverse path filtering. The basic concept of this feature is
that if a packet reply wouldn’t go out through the same interface the initial
packet got in, it is treated as a bogus packet and is dropped. This feature is
enabled by default in &sle; and can be check with the following command. This
should give back a 1 when it is enabled.</para>
<screen>cat /proc/sys/net/ipv4/conf/all/rp_filter</screen>
</listitem>
</varlistentry>

<varlistentry>
<term>Permit only established connections into the network</term>
<listitem>
<para>
SuSEfirewall2 directly enables connection tracking via iptables. Connections to
an interface that has been marked as external are dropped by default. Only
connections that associated with an established connection are allowed.</para>

<para>
It is possible to define certain services that are allowed to connect to the
external interface. However, this has to be in compliance with the general
security policy.</para>

<para>
Please keep in mind that the first line of defense to block malicious
connections from the internet should be a dedicated firewall system that
handles all traffic and acts as a gate keeper. Unwanted connections should
never reach the DMZ network. However, simple firewall rules on the SUSE Linux
Enterprise systems can help to avoid misconfiguration issues and act as another
line in the defense mechanism.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Do not disclose private IP addresses and routing information to
unauthorized parties</term>
<listitem>
<para>
A &sle; system can also act as a router to forward traffic from one interface
to another network on a second interface. It is possible to use Network Address
Translation (NAT) on the external interface so that no internal IP address is
actually exposed to outside. This is done to mitigate the information an
external attacker can gather by simply analyzing the network traffic. NAT can
also be used on virtulization hosts or container based environments that
connect to the outside via a specific interface.
</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2>
<title>Do not use vendor-supplied defaults for system passwords and other security parameters</title>
<para>
During system installation of &sle; general system passwords
are already set by the administrator. The setup uses also a password checker
(cracklib) that identifies weak entries against a common dictionary. So for
most services the standard configuration comes already with customer defined
security options.
</para>
<para>
This is also stated inside the SUSE Linux Enterprise Server Security and
Hardening Guide, that should be a general resource to tighten security
further. This helps to meet the requirements in this section.
</para>

<variablelist>
<varlistentry>
<term>Always change vendor-supplied defaults and remove or disable unnecessary
default accounts before installing a system on the network</term>
<listitem>
<para>
The configuration of any system service has to be evaluated to meet the needed
security standards. This goes from limiting the used protocols to only allow
currently secure versions and to disable legacy implementations, to the
definition of access controls and authentication. SUSE Linux Enterprise
predefined settings are already security aware, but settings can be tightened
ever further. For example, this is the case with the SNMP daemon where by
default incoming requests are only allowed to localhost. The default community
string is named 'public' and should be changed before accepting general inbound
connections.</para>

<para>
A second example are the default settings of the ssh daemon that are listed and
commented out inside the sshd configuration file '/etc/ssh/sshd_config'. On
default the insecure protocol 1 is already disabled. The same goes for
permitting empty passwords (PermitEmptyPasswords no). To tighten ssh security
it would best practice to deny direct root access by setting “PermitRootLogin”
to no.
</para>

<para>
Default settings can also be customized during automated system installation
via an AutoYaST profile. This makes it easy to roll out new instances of &sles;
and directly enable an evaluated configuration. The whole setup procedure can
even be completely automated with the SUSE Manager[2]. &sle; does not install
additional default accounts apart of the root administration user. There are
system accounts defined in /etc/passwd, but they are not activated and
therefore not directly reachable. This can be validated by checking the lines
inside the /etc/shadow file. The second column represents the defined
password. An asterisk (*) at this place means that no password was ever defined
and the account is therefore locked. An exclamation (!) stands for a locked
account and can stand all by itself or in front of a password hash.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Develop configuration standards for all system components. Assure that
these standards address all known security vulnerabilities and are consistent
with industry-accepted system hardening standards</term>
<listitem>
<para>
As mentioned inside the PCI DSS document, possible sources for
industry-accepted hardening standards are:
</para>

<itemizedlist>
<listitem>
<para>
Center for Internet Security (CIS)
</para>
</listitem>
<listitem>
<para>
International Organization for Standardization (ISO)
</para>
</listitem>
<listitem>
<para>
SysAdmin Audit Network Security (SANS) Institute
</para>
</listitem>
<listitem>
<para>
National Institute of Standards Technology (NIST)
</para>
</listitem>
</itemizedlist>

<para>
In general, as the PCI DSS requirements are quite fuzzy, there is no direct
mapping of hardening standards to specific requirements. However, any hardening
resource, including the SLES Security and Hardening Guide[1], help to fulfill
this specifications.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Implement only one primary function per server to prevent functions that
require different security levels from co-existing on the same server</term>
<listitem>
<para>
(For example, web servers, database servers, and DNS should be implemented on
separate servers.)
</para>

<para>
With &sles; it is easily possible to separate services by
using virtualization. SLES12 SP1 comes with the virtualization methods KVM,
Xen, Linux Containers and Docker to isolate services. This makes it easy to
fulfill the requirement and isolate services from each other. It is also
possible to run SLES on proprietary virtualization servers like VMware ESX or
Microsoft Hyper-V to achieve service separation.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Enable only necessary services, protocols, daemons, etc., as required for
the function of the system</term>
<listitem>
<para>
This requirement is aligned with the firewall requirement 1.1.6.b to allow only
services that are really needed and are using secure protocols and
settings. All involved parties need to be aware of the impact of using insecure
communication that could be comprised. The risk of using insecure protocols
and/or services should be clearly understood and documented.
</para>

<para>
Since SLES12 enabling and disabling system services is done via
systemd. Changes can be entered by using the systemctl tool.
</para>
<screen>systemctl status [SERVICE]
	systemctl enable [SERVICE]
	systemctl disable [SERVICE]</screen>

<para>
To list all available services that are installed on the system and see their status use the following command.
	systemctl list-unit-files –type=service
      </para>
</listitem>
</varlistentry>

<varlistentry>
<term>Inspect configuration settings to verify that security features are
documented and implemented for all insecure services, daemons, or
protocols</term>
<listitem>
<para>
One way to add an additional layer of security to insecure services is the
usage of VPN tunnels (i.e. IPsec). With this, the network traffic of such
services can be isolated and all data, internally and externally, is protected
against eavesdropping. It must be clear that the communication is still
insecure at the endpoints of the VPN tunnel and that this is just a workaround.
</para>
<para>
Additional security within SUSE Linux Enterprise Server can also be provided
with the usage of SELinux or AppArmor. At this stage the setup of these methods
is beyond the scope of this document. A good starting point to get familiar
with the SELinux framework is main chapter V of the SUSE Linux Enterprise
Server 12 SP1 Security Guide.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Select a sample of system components and inspect the configurations to
verify that all unnecessary functionality (for example, scripts, drivers,
features, subsystems, file systems, etc.) is removed</term>
<listitem>
<para>
One main system component is the Linux kernel that consist of a core image that
is extended by numerous kernel modules depending on the used hardware and
system design. Network card drivers are automatically loaded depending on the
availability inside the system and filesystem modules are used to extend the
Linux kernel's functionality. The list of loaded kernel modules is usually
quite long and includes modules that are only used occasionally. The kernel
module framework makes it easy to blacklist certain modules and to limit the
functionality.
</para>

<para>A simple way to block modules from being loaded is the configuration via
the /etc/modprobe.d directory. For instance, if we would like to prevent the
kernel module 'floppy' from being loaded, as systems these days have usually no
floppy drive anymore, we create the following configuration file.

File: /etc/modprobe.d/00-disable-modules.conf
	install floppy /bin/true
</para>

<para>
Please be aware that the floppy module is usually loaded during the execution of the initial ram disk. Therefore it is necessary to propagate such a configuration change to the initrd file. This has to be done via the ''mkinitrd'' script.
	mkinitrd
</para>
<para>
It is not that easy to do the same with application functionality. Usually the
functionality is compiled into the binaries itself or be part of a library,
which makes it impossible to being removed explicitly. Furthermore it has to be
clear that removed files that where part of an RPM package are reinstalled when
a package update is published.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Encrypt all non-console administrative access using strong
cryptography. Use technologies such as SSH, VPN, or TLS for web-based
management and other non-console administrative access
</term>
<listitem>
<para>
It is quite straight forward to fulfill this requirement. Any administrative
network access needs to be encrypted. The first tool of choice here is SSH with
appropriate configuration settings that fit into the security
concept. Administrative access can also be granted via a website. In this case
the complete connection chain between the browser and the server system needs
to be encrypted. This is done via TLS and x509 certificates.
</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2>
<title>Protect Cardholder Data</title>
<para>
The main prospect of this chapter is how to handle cardholder and
authentication data securely. Cardholder data are information like the
cardholder name and the Primary Account Number (PAN). Authentication data
include the Personal Identification Number (PIN) and the Card Validation Code
(CVC2). The main difference between cardholder data and authentication data is
the fact that it is not allowed to store the authentication data in any
case. The PAN on the other hand is allowed to be stored, but it needs to be
encrypted and unreadable in case someone gains access to the stored data.
</para>

<para>
As mentioned before in chapter 2 “Areas relevant to the Operating System” the
used database design for saving cardholder data is not inside the scope of the
OS. However, data encryption can be done in different ways. The DBMS can
directly use column-level encryption inside the database scheme or the used
files can be encrypted. The easiest way with SLES is to use full disk
encryption so that the whole database storage is always encrypted. It has to be
clear that access to the encrypted block device is the same as to a non
encrypted disk. This is discussed in 3.4.1 in more detail.
</para>
<variablelist>
  <varlistentry>
<term>If disk encryption is used, inspect the configuration and observe the
authentication process to verify that logical access to encrypted file systems
is implemented via a mechanism that is separate from the native operating
system's authentication mechanism (for example, not using local user account
databases or general network login credentials).</term>
<listitem>
<para>
The guidance description of the PCI DSS document says the following about this requirement:
"Full disk encryption helps to protect data in the event of physical loss of a
disk and therefore may be appropriate for portable devices that store
cardholder data."
</para>

<para>
From the administrator point of view a block device encryption with the Linux
Unified Key Setup (LUKS)/dm-crypt offers an abstraction layer that allows the
usage of fully encrypted devices in the same way as non encrypted
disks. Therefore access control can only be limited with the general ACL
permissions that the used filesystem offers. To be compliant with this
requirement the used decryption key cannot be associated with any general login
credentials or authentication methods. With LUKS this is usually the case as
the password needs to be entered separately during boot time, portable device
insertion or manual disk activation.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Examine the configurations and observe the processes to verify that
cardholder data on removable media is encrypted wherever stored</term>
<listitem>
<para>
As described in the last section, LUKS/dm-crypt is a full disk encryption
system that fulfills exactly this requirement. Access to the stored data is
only possible via a decryption password that needs to be entered during disk
insertion. The LUKS system in fully integrated into SLES and can be used via
YaST to create new partitions.
</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2>
<title>Encrypt transmission of cardholder data across open, public
networks</title>
<para>
Cardholder data has to be encrypted during transmissions over insecure
networks. Best practice would be to try to encrypt all traffic, externally and
internally, to make it as hard as possible for malicious individuals to gain
inside information and possible privileged access to the cardholder data
environment.
</para>

<variablelist>
<varlistentry>
<term>Use strong cryptography and security protocols (for example, TLS, IPSEC,
SSH, etc.) to safeguard sensitive cardholder data during transmission over
open, public networks, including the following:
</term>
<listitem>
<itemizedlist>
<listitem>
<para>
Only trusted keys and certificates are accepted
</para>
</listitem>
<listitem>
<para>
The protocol in use only supports secure versions or configurations
</para>
</listitem>
<listitem>
<para>
The encryption strength is appropriate for the encryption methodology in use
</para>
</listitem>
</itemizedlist>

<para>
Every connection that transmits sensitive information has to be protected against eavesdropping and tampering.
For incoming client requests this can be done via HTTPS that is using a secure
TLS connection. The authentication is done with a public x.509 certificate that
proves to a certain level that the server is the right endpoint the customer is
looking for.
</para>

<para>
SLES comes with a set of services and tools that allow protected HTTPS
connections, i.e. this can be directly done with the Apache HTTP Server or via
stunnel that functions as a proxy to offer TLS encryption functionality. IPsec
or other VPN technologies can be used for securing the connection between
network segments that are connected via a public network. This connections can
also be secured with a public x.509 certificate. For internal usage it would be
possible to use a private Certificate Authority (CA) to sign x.509 certificates
and to keep track on trusted keys. In SLES this can be directly established
with strongSwan that is a IPsec-based VPN solution or with OpenVPN that is
using a custom security protocol.
</para>

<para>
Administration access to the OS level is usually done via SSH. Configuration
and authentication can be tightened to meet the needed security. This was
partially stated before inside the requirements 1 and 2.
</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2>
<title>Maintain a Vulnerability Management Program</title>
<variablelist>
<varlistentry>
<term>Protect all systems against malware and regularly update anti-virus
software or programs</term>
<listitem>
<para>
For PCI DSS compliance it is necessary to protect against malicious software
threats. Commercial anti-virus software is available from the major anti-virus
software vendors and can be integrated into the Linux environment. SLES itself
comes with the open source anti-virus engine ClamAV.
</para>

<para>
The question here is which functionality and performance is needed. ClamAV has
a limited set of scanning capabilities and limited performance compared to
commercial products. So the expectations have to be clear that ClamAV only
gives only a simple protection level.
</para>

<para>
On the other hand ClamAV is directly shipped with SLES and can be included
during server installation. This makes it easy to fulfill the details of this
requirement, but the drawbacks compared to commercial products have to be
clearly understood.
</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term>Requirement 6: Develop and maintain secure systems and
applications</term>
<listitem>
<para>
A powerful instrument in SUSE Linux Enterprise is the command-line tool zypper
that is an interface to the ZYpp system management library (libzypp). Among
other things it solves packages, products, patterns and patches dependencies,
has a locking mechanism to prevent package installation and provides a complete
update stack to keep the system up to date and protected against know security
issues. The zypper tool is part of any SLES installation and has direct access
to the update repositories after system registration.
</para>

<para>
For system management we provide SUSE Manager that provides an efficient way to
keep systems up-to-date. It offers seamless management of both SUSE Linux
Enterprise and Red Hat Enterprise Linux client systems. This is particularly
handy in larger system environments, to check the current update status of each
system and to react on know security risks.
</para>

<para>
Most parts of this requirement are about in-house security software
development, documentation and design questions. In this prospect we will keep
our scope on how to keep the operating system maintained and secure.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Examine policies and procedures related to security patch installation to
verify processes are defined for:</term>

<listitem>
<itemizedlist>
<listitem>
<para>
Installation of applicable critical vendor-supplied security patches within one
month of release
</para>
</listitem>
<listitem>
<para>
Installation of all applicable vendor-supplied security patches within an
appropriate time frame (for example, within three months)
</para>
</listitem>
</itemizedlist>

<para>
The following command examples will show how to identify patches that need to be installed in order to run a secure system.
First refresh all software repositories so that we have up-to-date
information.</para>

<screen>zypper refresh</screen>

<para>
Now we can look for important security fixes that have not yet been installed
</para>

<screen>zypper list-patches --category security --severity important</screen>

<para>
It is also possible to search for CVE or SUSE bugzilla numbers. By default only
needed patches are listed by this commands. To show also patches that have
already been installed use the --all switch. 
</para>

<screen>zypper list-patches --all --cve=CVE-2016-4957</screen>

<para>
Details of individual patches can be listed with the patch-info
sub-command.</para>

<screen>zypper patch-info SUSE-SLE-SERVER-12-SP1-2016-600</screen>

<para>
To install only important security patches use the patch command. All zypper
commands can be run with the --non-interactive switch to run
automatically.
</para>

<screen>zypper patch --category security --severity important</screen>

</listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2>
<title>Implement Strong Access Control Measures</title>
<variablelist>
<varlistentry>
<term>Restrict access to cardholder data by business need to know</term>
<listitem>
<para>
Access control is a complex topic if it comes to the operating system. Again,
the PCI DSS requirement is quite fuzzy at this point and does not specifically
state to which degree the restriction has to be fulfilled. SUSE Linux
Enterprise comes with all general Linux tools to limit and restrict access to
certain system areas and components. Access can be controlled via specific
users and groups of users. This are the traditional Unix permission settings. A
more flexible mechanism for file systems are Access Control Lists (ACLs) that
offer a more graduated approach. SELinux can be used to separate the system to
a maximum and to protect processes from gaining more resources and access then
allowed.
</para>
<para>
As stated before, SELinux and AppArmor are not inside the scope of this
guide. However, to protect critical systems that could be potentially targeted
it would be a good idea to look into the capabilities of these security
mechanisms further. A documentation how to set up and manage SELinux can be
found in chapter V inside the SUSE Linux Enterprise Server 12 SP1 Security
Guide.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Restrict access to privileged user IDs to least privileges necessary to
perform job responsibilities</term>
<listitem>
<para>
The standard UNIX permissions allow the setting of Read, Write and Execution
flags for user and group IDs. A general group called “Others” or “World”
defines the access for users that do not fit into the first two groups. This
allows a straight forward way to gain or deny access to file system resources.
</para>

<para>
ACLs allow an extra level of restriction. It is possible to set read-write
access for one user ID and only read access to a second one. The same goes for
group IDs. The command-line tools are included inside the acl package and allow
direct modification of filesystem resources.
</para>

<screen>getfacl /tmp/test.txt
	setfacl -m “u:dbuser:rw” /tmp/test.txt
	getfacl /tmp/test.txt</screen>

<para>
Standard UNIX permissions come also with a so called StickyBit. This allows the
execution of certain programs with higher privileges then the user who is
executing those programs. The best example for this is the passwd tool that
needs to modify the /etc/shadow in order to change the users password.</para>

<para>In respect to the StickyBit Linux capabilities are also a way to
explicitly allow certain operations or behaviors to binaries. An example for
this is the ping command from the iputils package. It has no StickyBit but
needs to be able to send ICMP IP packets over the network card. For this it has
the CAP_NET_RAW capability that is Effective and Permitted (+ep).</para>

<screen>getcap /usr/bin/ping
	/usr/bin/ping = cap_net_raw+ep</screen>

<para>
Login access control to the system can be managed via the pluggable
authentication module (PAM) mechanism. There are several modules directly
available in SUSE Linux Enterprise that allow setups like control of the login
time, multiple authentication mechanisms and central databases like NIS, LDAP
or Active Directory.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Remove/disable inactive user accounts within 90 days</term>
<listitem>
<para>
It should be common practice to use a centralized infrastructure for user
accounts like NIS, LDAP or Active Directory. With this inactive accounts can
easily identified and disabled automatically. A centralized infrastructure has
also the advantage that a user account needs to be disabled in one place
only. After access has been revoked a user is unable to perform any service
that relies on the centralized account infrastructure.</para>

<para>
Local accounts on the other hand can be checked for inactivity during user
login. This can be done with the pluggable authentication module (PAM)
pam_lastlog. That module checks the last login time that was recorded in
/var/log/lastlog and calculates the number of days since. By default access is
denied when the inactivity reaches 90 days. To list the local accounts last
login time use the lastlog command.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Limit repeated access attempts by locking out the user ID after not more
than six attempts</term>
<listitem>
<para>
As already stated for requirement 8.1.4 a centralized account infrastructure
will have this capability. On the SUSE Linux Enterprise system we can check and
limit access attempts with the pam_tally2 PAM module. The module is executed
during login time and checks the recorded failed attempts since the last
successful login. The pam_tally2 command-line tool can be used to check and
reset the account status.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Set the lockout duration to a minimum of 30 minutes or until an
administrator enables the user ID</term>
<listitem>
<para>
The pam_tally2 PAM module that was described in requirement 8.1.6 can be used
to lock an account for a given time after a failed login attempt. The parameter
‘unlock_time=1800’ has to be configured into the PAM configuration. The default
setting is that only the administrator can reactivate a locked account.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Incorporate multi-factor authentication for all non-console access into
the CDE for personnel with administrative access</term>
<listitem>
<para>
Multi-factor authentication for administrative access can be done via the
pluggable authentication module (PAM) mechanism. This makes it flexible to add
new methods to the authentication process and to adjust it if needed. Another
way of multi-factor authentication for SSH connections is the additional usage
of public keys. To connect to a system it is necessary to prove that you are in
the possession of the appropriate private key. When accepted you need to enter
a password at the second stage. With this brute force password crackers need to
get there hands on a private key before they get a password prompt. Commercial
one-time password (OTP) products usually have also a Linux PAM module available.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Incorporate multi-factor authentication for all remote network access
(both user and administrator, and including third-party access for support or
maintenance) originating from outside the entity’s network</term>
<listitem>
<para>
See 8.3.1 for details
</para>
</listitem>
</varlistentry>

</sect1>
</appendix>
